/* -*- mode:C++ -*-
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2002-2012, Markus Sch√ºtz
//
// This library is free software. You can redistribute  and/or  modify it under
// the terms of the GNU Lesser General Public License  as published by the Free
// Software Foundation.  Either version 2.1 of the License, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,  but WITHOUT
// ANY  WARRANTY.  Without  even  the  implied  warranty  of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
// for more details.
//
// You should have received  a  copy  of  the GNU Lesser General Public License
// along with this library. If not, write to the Free Software Foundation, Inc,
// 59  Temple Place,  Suite 330,  Boston,  MA  02111-1307  USA,  or consult URL
// http://www.gnu.org/licenses/lgpl.html.
//
///////////////////////////////////////////////////////////////////////////////
//
// Thread start descriptor.
// Stores the thread's main function and the arguments handle.
// Everything is stored as void* (untyped pointer) so that:
//   1) Thread::Start can be untemplated itself.
//   2) Thread startup code can be linked into the library.
// Reason 1) is to keep things simple for the end developer.
// Reason 2) is to have as few as possible things in the _lisle_ namespace
// visible in installed interfaces. End developers should not see it as far
// as possible so they can concentrate on their work, not on library internal
// details.
//
///////////////////////////////////////////////////////////////////////////////
*/
#pragma once
#include <lisle/exceptions>
#include <lisle/Handle>
#include <lisle/Anondle>
#include <lisle/Schedule>

namespace lisle { class Thread; }
namespace lisle { void launch (const lisle::Thread&); }

namespace lisle {
class Thread
{
	friend void lisle::launch (const lisle::Thread&);
public:
	typedef Anondle(* Caller)(void(*)(),Anondle&);
	typedef void(* Callee)();
	enum State { Joinable, Detached };
	enum Mode { Running, Suspended };
	~Thread () {}
	Thread () {}
	Thread (const Thread& that) : data(that.data) {}	
	Thread& operator = (const Thread& that) { this->data = that.data; return *this; }
	Thread (void(* main)(), Mode mode = Running, State state = Joinable) : data(&caller00, main, mode, state) {}
	template <typename TAT> Thread (void(* main)(lisle::Handle<TAT>), const lisle::Handle<TAT>& args, Mode mode = Running, State state = Joinable) : data((Caller)(Anondle(*)(void(*)(lisle::Handle<TAT>),Anondle&))&caller01<TAT>, (Callee)main, args, mode, state) {}
	template <typename TRT> Thread (lisle::Handle<TRT>(* main)(), Mode mode = Running, State state = Joinable) : data((Caller)(Anondle(*)(lisle::Handle<TRT>(*)(),Anondle&))&caller10, (Callee)main, mode, state) {}
	template <typename TRT, typename TAT> Thread (lisle::Handle<TRT>(* main)(lisle::Handle<TAT>), const lisle::Handle<TAT>& args, Mode mode = Running, State state = Joinable) : data((Caller)(Anondle(*)(lisle::Handle<TRT>(*)(lisle::Handle<TAT>),Anondle&))&caller11, (Callee)main, args, mode, state) {}
	void set (void(* main)()) { data.call = &caller00; data.main = main; data.args = Anondle(); }
	template <typename TAT> void set (void(* main)(lisle::Handle<TAT>), const lisle::Handle<TAT>& args) { data.call = (Caller)(Anondle(*)(void(*)(lisle::Handle<TAT>),Anondle&))&caller01; data.main = (Callee)main; data.args = args; }
	template <typename TRT> void set (lisle::Handle<TRT>(* main)()) { data.call = (Caller)(Anondle(*)(lisle::Handle<TRT>(*)(),Anondle&))&caller10; data.main = (Callee)main; data.args = Anondle(); }
	template <typename TRT, typename TAT> void set (lisle::Handle<TRT>(* main)(lisle::Handle<TAT>), const lisle::Handle<TAT>& args) { data.call = (Caller)(Anondle(*)(lisle::Handle<TRT>(*)(lisle::Handle<TAT>),Anondle&))&caller11; data.main = (Callee)main; data.args = args; }
	void set (State state) { data.state = state; }
	void set (Mode mode) { data.mode = mode; }
	Caller call () const { return data.call; }
	Callee main () const { return data.main; }
	Anondle& args () const { return data.args; }
	State state () const { return data.state; }
	Mode mode () const { return data.mode; }
private:
	struct Data
	{
		Caller call;
		Callee main;
		mutable Anondle args;
		Mode mode;
		State state;
		Data () : call(0), main(0), mode(Running), state(Joinable) {}
		Data (const Data& that) : call(that.call), main(that.main), args(that.args), mode(that.mode), state(that.state) {}
		Data (Caller call, void(* main)(), Mode mode, State state) : call(call), main(main), mode(mode), state(state) {}
		Data (Caller call, void(* main)(), const Anondle& args, Mode mode, State state) : call(call), main(main), args(args), mode(mode), state(state) {}
	} data;
	static Anondle caller00 (void(* main)(), Anondle&)
	{
		(*main)();
		return Anondle();
	}
	template <typename TAT> static Anondle caller01 (void(* main)(lisle::Handle<TAT>), Anondle& args)
	{
		(*main)(*args.handle<TAT>());
		return Anondle();
	}
	template <typename TRT> static Anondle caller10 (lisle::Handle<TRT>(* main)(), Anondle&)
	{
		return Anondle((*main)());
	}
	template <typename TRT, typename TAT> static Anondle caller11 (lisle::Handle<TRT>(* main)(lisle::Handle<TAT>), Anondle& args)
	{
		return Anondle((*main)(*args.handle<TAT>()));
	}
};
}
